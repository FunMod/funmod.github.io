<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://funmod.github.io</id>
    <title>FunMod</title>
    <updated>2024-11-11T09:24:14.501Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://funmod.github.io"/>
    <link rel="self" href="https://funmod.github.io/atom.xml"/>
    <subtitle>æ¸©æ•…è€ŒçŸ¥æ–°</subtitle>
    <logo>https://funmod.github.io/images/avatar.png</logo>
    <icon>https://funmod.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, FunMod</rights>
    <entry>
        <title type="html"><![CDATA[C2000---å¢å¼ºå‹è„‰å®½è°ƒåˆ¶ (EPWM) å®éªŒ]]></title>
        <id>https://funmod.github.io/post/c2000-zeng-qiang-xing-mai-kuan-diao-zhi-epwm-shi-yan/</id>
        <link href="https://funmod.github.io/post/c2000-zeng-qiang-xing-mai-kuan-diao-zhi-epwm-shi-yan/">
        </link>
        <updated>2024-11-11T09:23:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c2000-å¢å¼ºå‹è„‰å®½è°ƒåˆ¶-epwm-å®éªŒ">C2000---å¢å¼ºå‹è„‰å®½è°ƒåˆ¶ (EPWM) å®éªŒ</h1>
<p>æœ¬å®éªŒçš„ç›®æ ‡æ˜¯ç†Ÿæ‚‰å¢å¼ºå‹è„‰å®½è°ƒåˆ¶ (EPWM) æ¨¡å—ã€‚ EPWM æ¨¡å—å°†é…ç½®ä¸ºç”ŸæˆæŒ‡å®šé¢‘ç‡å’Œå ç©ºæ¯”çš„ PWM ä¿¡å·ã€‚ç„¶åï¼Œæ¨¡æ•°è½¬æ¢å™¨ (ADC) å°†ç”¨äºå¯¹è¯¥ PWM ä¿¡å·è¿›è¡Œé‡‡æ ·ã€‚è¿™å°†éœ€è¦ç¬¬äºŒä¸ª EPWM ä¿¡å·æ¥è§¦å‘ ADC è½¬æ¢å¼€å§‹ (SOC) ä¿¡å·ï¼Œä»¥ä¾¿ ADC å¼€å§‹é‡‡æ ·ã€‚æˆ‘ä»¬è¿˜å°†ä½¿ç”¨å¢å¼ºå‹æ•è· (ECAP) æ¨¡å—æµ‹é‡ç¬¬ä¸€ä¸ª PWM ä¿¡å·çš„å ç©ºæ¯”å’Œå‘¨æœŸã€‚</p>
<p>åœ¨æœ¬å®éªŒä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ Sysconfig GUI é€šè¿‡ EPWM æ¨¡å—ä¹‹ä¸€ç”Ÿæˆæ³¢å½¢ã€‚ PWM æ³¢å½¢çš„å‘¨æœŸå’Œå ç©ºæ¯”å°†ç”± ECAP æ¨¡å—ä¹‹ä¸€æµ‹é‡ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ ADC å¯¹ PWM æ³¢å½¢è¿›è¡Œé‡‡æ ·ã€‚æˆ‘ä»¬å°†ç›¸åº”çš„æ ·æœ¬å­˜å‚¨åœ¨å¾ªç¯ç¼“å†²åŒºä¸­ï¼Œè¿™å°†å…è®¸æˆ‘ä»¬åœ¨ Code Composer Studio è°ƒè¯•ä¼šè¯ä¸­æŸ¥çœ‹ PWM æ³¢å½¢ã€‚ SysConfig GUI å·¥å…·è¿˜å°†ç”¨äºé…ç½® ECAP å’Œ ADC æ¨¡å—ã€‚</p>
<figure data-type="image" tabindex="1"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm_intro.png" alt="lab_epwm_intro" loading="lazy"></figure>
<h2 id="start-a-ccs-project">Start a CCS Project</h2>
<p>Our first task is to import an empty project to our Code Composer Studio (CCS) workspace. The basic instructions are as follows:</p>
<ol>
<li>Open CCS and go to <strong>Projectâ†’Import CCS Projects</strong>. A new window should appear. Ensure that the <strong>Select search-directory</strong> option is activated.</li>
<li>Click the <strong>Browse</strong> button and select the <code>[C20000ware_Install_dir]/training/device/[device]/empty_lab</code> directory. Note that the default Windows [C20000ware_Install_dir] is <code>C:/ti/c2000/C2000Ware_x_xx_xx_xx</code>.</li>
<li>Under <strong>Discovered Projects</strong>, you should now see the <code>lab_[board]_[device]</code> project. Select the appropriate project for either the control card or the launchpad.</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/project_start4.png" alt="Discovered_Projects" loading="lazy"></figure>
<ol>
<li>Click <strong>Finish</strong> to import and copy the <code>lab_[board]_[device]</code> project into your workspace.</li>
<li>After the project has been imported, the project explorer window should look like below:</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/project_view4.png" alt="Projects_explorer" loading="lazy"></figure>
<ol>
<li>Rename the project to your liking
<ul>
<li>Right-click on the project in â€œProject Explorerâ€ pane. Select â€˜Renameâ€™ from the drop down menu and rename the project to â€˜c2000_epwm_labâ€™ or a name of your choosing.</li>
<li>Now click the â€˜Down Arrowâ€™ located to the left of the imported project to expand it and select lab_main.c. Right-click on the file, and select â€˜Renameâ€™ to rename the file to c2000_epwm_lab_main.c or a name of your choosing.</li>
</ul>
</li>
</ol>
<h2 id="configure-the-gpio">Configure the GPIO</h2>
<p>We will first set up a GPIO so that we can use one of the board LEDs as an indicator. To add the LED GPIO configuration:</p>
<ul>
<li>In the project, open the <code>.syscfg</code> file by double-clicking it.</li>
<li>In the SysConfig GUI, select the â€œHardwareâ€ tab</li>
<li>If you have a Launchpad, click â€˜+â€™ next to â€˜LEDâ€™ to add LED5. If you have a controlCard, click â€˜+â€™ to add D2.</li>
</ul>
<figure data-type="image" tabindex="4"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm_led.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm_led.png" alt="../../../_images/lab_epwm_led.png" loading="lazy"></a></figure>
<p>\</p>
<ul>
<li>Select the LED option like below.</li>
</ul>
<figure data-type="image" tabindex="5"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm_led2.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm_led2.png" alt="../../../_images/lab_epwm_led2.png" loading="lazy"></a></figure>
<p>\</p>
<h2 id="configure-the-epwms">Configure the EPWMs</h2>
<p>For Devices F2837xD, F2837xS, F2838x, F28003x, F280013x, F280015x, F28P65x, and F28P55x:</p>
<p>The SYSCLK generated from the internal oscillator is higher than 100MHz on these devices. For example, the EPWM clock for F28003x is 120MHz. The maximum EPWM clock is still 100MHz on F2837xD, F2837xS, and F2838x, but the ADC clock is equal to the device SYSCLK. When clock dividers are selected in the following modules, you may need to modify your dividers to achieve exactly the same results.</p>
<p>You may also notice that your device has different parameters than the ones seen in the images below. Do not worry, as all of the essential parameters for this lab are available on all devices.</p>
<h3 id="set-up-epwm1">Set Up EPWM1</h3>
<p>We will now configure EPWM1A to output a 2kHz PWM waveform with a 25% duty cycle. We will begin by setting the EPWM clock prescalars. The EPWM clock frequency has been set to be 100MHz. If you have a F2837xD or F2838x based device, the EPWM clock frequency is half of <code>DEVICE_SYSCLK_FREQ</code> by default, otherwise <code>DEVICE_SYSCLK_FREQ</code> and the EPWM clock frequency are equal. Since the time base counter is 16 bits wide and (10^8/2000 &lt; 2^16), there is no need to divide the EPWM clock. Hence, we set the clock division to 1.</p>
<p>Next, we will set the time base period. In this lab, we will use up-down-count mode which yields a symmetric PWM waveform. This leads to the following calculations for the time base period:</p>
<p>Time Base Period=ftbclk/2fpwm</p>
<p>Note that for just up-count mode or down-count mode, the calculation would be:</p>
<p>Time Base Period=ftbclk/fpwmâˆ’1.</p>
<p>Additionally, we will set the period load mode to shadow load mode, and we will set the phase shift to be 0 since we will not be performing any synchronization.</p>
<p>Next, we will configure the parameters of the counter compare module for EPWM1A to achieve a 25% duty cycle. Since we are will be in up-down-count mode, a counter compare event will happen twice: once while counting up, and once while counting down. This suggests the following for a 25% duty cycle:</p>
<p>Counter Compare Value=(1âˆ’duty100)âˆ—tbprd=(1âˆ’25100)25000=18750</p>
<p>Notice that the global variable <code>ePwm_curDuty</code> will be initialized accordingly. For the strict up-count or down-count modes, the calculation would be:</p>
<p>Counter Compare Value=(1âˆ’duty100)âˆ—(tbprd+1)âˆ’1.</p>
<p>Next, we will set the counter compare load mode so that it loads a new counter compare value on when the EPWM counter is at zero or at the period value. This will allow us to change the value of <code>ePwm_curDuty</code> in a real-time CCS debug session. Shadow load mode is also enabled to avoid output glitches when we change the counter compare value.</p>
<p>Finally, we will set the counter mode to up-down-count mode. Note that we still will not have enabled the clock to the EPWM modules. This will complete the configuration of EPWM1A.</p>
<ul>
<li>To implement the above described specifications for EPWM1 in SysConfig, first click the â€˜+â€™ by the EPWM module of the SysConfig â€˜Softwareâ€™ tab to add an instance of EPWM module.</li>
</ul>
<figure data-type="image" tabindex="6"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/epwm_start_11.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/epwm_start_11.png" alt="../../../_images/epwm_start_11.png" loading="lazy"></a></figure>
<p>\</p>
<ul>
<li>Expand the â€˜EPWM Time Baseâ€™ dropdown menu, and apply the changes circled below.</li>
<li>Expand the â€˜EPWM Counter Compareâ€™ dropdown menu, and again apply the circled changes.</li>
</ul>
<figure data-type="image" tabindex="7"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm1_12.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm1_12.png" alt="../../../_images/lab_epwm1_12.png" loading="lazy"></a></figure>
<p>\</p>
<ul>
<li>Expand the â€˜EPWM Action Qualifierâ€™ dropdown menu, then apply the changes circled below.</li>
</ul>
<figure data-type="image" tabindex="8"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm1_21.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm1_21.png" alt="../../../_images/lab_epwm1_21.png" loading="lazy"></a></figure>
<p>\</p>
<ul>
<li>Expand the â€˜EPWMxA Event Output Configurationâ€™ dropdown menu, then apply the changes circled below.</li>
</ul>
<figure data-type="image" tabindex="9"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm1_actions1.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm1_actions1.png" alt="../../../_images/lab_epwm1_actions1.png" loading="lazy"></a></figure>
<p>\</p>
<ul>
<li>Expand the â€˜PinMux Peripheral and Pin Configurationâ€™ dropdown menu. For â€˜EPWM Peripheralâ€™, make sure to select instance EPWM1. Also, make sure to select â€˜GPIO0â€™ for â€˜EPWMAâ€™ and select â€˜GPIO1â€™ for â€˜EPWMBâ€™, as shown below. The pin number will vary based on hardware.</li>
</ul>
<figure data-type="image" tabindex="10"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm1_32.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm1_32.png" alt="../../../_images/lab_epwm1_32.png" loading="lazy"></a></figure>
<p>\</p>
<h3 id="set-up-epwm2">Set Up EPWM2</h3>
<p>In order to view the EPWM1 waveform in CCS, we will sample the EPWM1 waveform using the ADC. In general, EPWM modules can be used to trigger a start-of-conversion (SOC) event on the ADC. We will use this technique in this lab by sampling our EPWM1 waveform at a sampling rate of 50kHz via EPWM2 which will be used trigger the ADC sampling. The first steps in the configuration of EPWM2 will be identical to EPWM1. However, we will use the <strong>up-count</strong> mode rather than the <strong>up-down-count mode</strong>. Thus, to achieve a sampling rate of 50kHz, we need</p>
<p>Time Base Period=100âˆ—10650000âˆ’1=1999.</p>
<p>Next, we will configure EPWM2 to trigger an SOC on the ADC. Notice that the trigger source will be the event where the EPWM counter reaches the time base period value. Hence, an SOC event will occur once per EPWM2 period at a rate of 50kHz. The event prescale setting will be set to 1 since we would like the SOC to happen at each event where the counter is equal to the time base period.</p>
<ul>
<li>To implement the above described specifications for EPWM2 in SysConfig, click the â€˜+â€™ by EPWM to open a second instance of the EPWM module.</li>
</ul>
<figure data-type="image" tabindex="11"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/epwm_start_21.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/epwm_start_21.png" alt="../../../_images/epwm_start_21.png" loading="lazy"></a></figure>
<p>\</p>
<ul>
<li>Expand the â€˜EPWM Time Baseâ€™ dropdown menu, and apply the changes circled below.</li>
</ul>
<figure data-type="image" tabindex="12"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm2_12.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm2_12.png" alt="../../../_images/lab_epwm2_12.png" loading="lazy"></a></figure>
<p>\</p>
<ul>
<li>Expand the â€˜EPWM Event-Triggerâ€™ dropdown menu, and apply the changes circled below.</li>
</ul>
<figure data-type="image" tabindex="13"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm2_22.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm2_22.png" alt="../../../_images/lab_epwm2_22.png" loading="lazy"></a></figure>
<p>\</p>
<ul>
<li>Expand the â€˜PinMux Peripheral and Pin Configurationâ€™ dropdown menu, and apply the changes circled below. Also, make sure to select â€˜GPIO2â€™ for â€˜EPWMAâ€™ and select â€˜GPIO3â€™ for â€˜EPWMBâ€™, as shown below. The pin number will vary based on hardware.</li>
</ul>
<figure data-type="image" tabindex="14"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm2_32.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_epwm2_32.png" alt="../../../_images/lab_epwm2_32.png" loading="lazy"></a></figure>
<p>\</p>
<p>This concludes the configuration of the EPWM modules.</p>
<h2 id="configure-the-adc">Configure the ADC</h2>
<p>In the previous section, we explained that EPWM2 would be triggering a SOC event on the ADC. In this section, we will provide the code to configure the ADC. More details about the configuration of the ADC can be found in <a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/source/c2000_analog_subsystem/c2000_analog_to_digital_converter.html">Analog-to-Digital Converter (ADC)</a>. However, notice that we have setup a SOC to be triggered by EPWM2 and that we have setup the ADC to interrupt at the end of a conversion. Hence, the interrupt service routine will be triggered at a rate of 50kHz. The ADC is also setup in continuous mode so that the ADC register always contains the most recent sample.</p>
<ul>
<li>Add ADC by clicking the â€˜+â€™ by ADC in the SysConfig screen. Make sure to make the changes circled below. If your device SYSCLK is not 100MHz, you will need to change the ADC Clock Prescaler to acheive the same results.</li>
<li>For the â€˜SOC0 Sample Window[SYSCLK counts]â€™ parameter, the same value may result in a different â€˜SOC0 Sample Time[ns]â€™ on different devices, due to varying SYSCLK frequencies across devices. Make sure that the generated â€˜SOC0 Sample Time[ns]â€™ is about 80ns.</li>
</ul>
<figure data-type="image" tabindex="15"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/epwm_adc_11.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/epwm_adc_11.png" alt="../../../_images/epwm_adc_11.png" loading="lazy"></a></figure>
<p>\</p>
<ul>
<li>Expand the â€˜Register PIE Interrupt Handlersâ€™ dropdown menu, and register Interrupt 1, as shown below. This should trigger the â€˜ADCA Interrupt 1â€™ dropdown menu to appear.</li>
<li>Expand the â€˜ADCA Interrupt 1â€™ dropdown menu, and change the interrupt handler to â€˜adcA1ISRâ€™. Make sure this interrupt handler matches the name of the interrupt in the ISR code snippet below. Also click the checkbox to enable the interrupt in PIE, as shown below.</li>
</ul>
<figure data-type="image" tabindex="16"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_adc_21.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_adc_21.png" alt="../../../_images/lab_adc_21.png" loading="lazy"></a></figure>
<p>\</p>
<p>For devices F28002x, F28003x, F280013x, F280015x, F28P65x, and F28P55x:</p>
<p>Set analog reference voltage using asysctl parameter.</p>
<p>Add ASYSCTL by clicking â€˜+â€™ in ANALOG group and then add internal reference of 1.65V.</p>
<figure data-type="image" tabindex="17"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/lab_adc_internal_ref2.png" alt="ASYSCTL" loading="lazy"></figure>
<p>If using F28P65x LaunchPad, be sure to remove the external voltage reference jumper from your LaunchPad to generate the correct output signals for this lab.</p>
<h3 id="set-up-the-adc-isr">Set Up the ADC ISR</h3>
<p>In this section, we will define the ADC interrupt service routine (ISR). This ISR will store samples from the ADC in a circular buffer so that we can view the EPWM1 waveform using the real-time debug features in CCS. The necessary code is shown below. In addition to storing the ADC samples in a circular buffer, this ISR also toggles one of the board LEDs at a rate of 1Hz and allows for the duty cycle of EPWM1A to be changed on the fly or be modulated during a CCS debug session.</p>
<p>The global flag variable <code>DutyModOn</code> controls whether or not the duty cycle is modulated:</p>
<ul>
<li>When <code>DutyModOn</code> is set to 1, the PWM waveform duty cycle slowly scale from 5% to 95% and back down to 5% (and repeat).</li>
</ul>
<p>Copy the following code into your source .c file:</p>
<pre><code>__interrupt void adcA1ISR(void)
{
    // Clear interrupt flags.
    Interrupt_clearACKGroup(INT_myADC0_1_INTERRUPT_ACK_GROUP);
    ADC_clearInterruptStatus(myADC0_BASE, ADC_INT_NUMBER1);
    // Write contents of the ADC register to a circular buffer.
    *AdcBufPtr = ADC_readResult(myADC0_RESULT_BASE, myADC0_SOC0);
    if (AdcBufPtr == (AdcBuf + 49))
    {
        // Force buffer to wrap around.
        AdcBufPtr = AdcBuf;
    } else {
        AdcBufPtr += 1;
    }
    if (LedCtr &gt;= 49999) {
        // Divide 50kHz sample rate by 50e3 to toggle LED at a rate of 1Hz.
        GPIO_togglePin(myBoardLED0_GPIO);
        LedCtr = 0;
    } else {
        LedCtr += 1;
    }
    if (DutyModOn) {
        // Divide 50kHz sample rate by 16 to slow down duty modulation.
        if (DutyModCtr &gt;= 15) {
            if (DutyModDir == 0) {
                // Increment State =&gt; Decrease Duty Cycle.
                if (ePwm_curDuty &gt;= ePwm_MinDuty) {
                    DutyModDir = 1;
                } else {
                    ePwm_curDuty += 1;
                }
            } else {
                // Decrement State =&gt; Increase Duty Cycle.
                if (ePwm_curDuty &lt;= ePwm_MaxDuty) {
                    DutyModDir = 0;
                } else {
                    ePwm_curDuty -= 1;
                }
            }
            DutyModCtr = 0;
        } else {
            DutyModCtr += 1;
        }
    }
    // Set the counter compare value.
    EPWM_setCounterCompareValue(myEPWM0_BASE, EPWM_COUNTER_COMPARE_A, ePwm_curDuty);
}
</code></pre>
<h2 id="configure-the-ecap">Configure the ECAP</h2>
<p>We can use the ECAP peripheral to measure the duty cycle and period of our EPWM1 waveform. We start by resetting the ECAP1 peripheral, disabling time stamp capture, and stopping the internal counter. This will put the ECAP1 registers in a known state, and it will freeze the internal ECAP counter. This way, when we start the ECAP, it will initially behave in a predictable manner. This can be very important for many practical usage scenarios.</p>
<ul>
<li>To begin setting up the ECAP, clicking the â€˜+â€™ next to the ECAP module in SysConfig.</li>
</ul>
<p>The following setup will enable continuous capture mode with 4 sequential timestamped events. Notice the configuration of the 4 different event polarities. This configuration will allow us to measure the duty cycle from events 1 and 2, and measure the period from events 1 and 3. Since we need the internal counter to hold its count from event 1 to event 4, we have disabled the counter reset on these events. Also notice that the ECAP input will be the signal from <code>XBAR_INPUT7</code>. GPIO0 (which contains our EPWM1 waveform) will be mapped to <code>XBAR_INPUT7</code> so that it is the source of the input to the ECAP.</p>
<figure data-type="image" tabindex="18"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/ecap_1.png" alt="ECAP1" loading="lazy"></figure>
<p>Next, we enable an interrupt after event 3 is captured. This allows us to calculate the period and duty cycle in the interrupt service routine.</p>
<ul>
<li>Expand the â€˜ECAP Interruptâ€™ dropdown menu</li>
<li>Change the interrupt handler to â€˜ecap1ISRâ€™. Make sure this interrupt handler matches the name of the interrupt in the ISR code snippet below.</li>
<li>Click the checkbox to enable the interrupt in PIE, as shown below.</li>
</ul>
<figure data-type="image" tabindex="19"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/ecap_2.png" alt="ECAP2" loading="lazy"></figure>
<h3 id="set-up-inputxbar7">Set Up InputXBAR7</h3>
<p>Now, GPIO0 (which contains our EPWM1 waveform) will be mapped to <code>XBAR_INPUT7</code> below.</p>
<ul>
<li>Add INPUTXBAR by clicking the â€˜+â€™ in SysConfig, and apply the changes circled below. Make sure the interrupt handler matches the name of the interrupt in the ISR code snippet below.</li>
</ul>
<figure data-type="image" tabindex="20"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/inputxbar.png" alt="INPUTXBAR" loading="lazy"></figure>
<h3 id="set-up-the-ecap-isr">Set Up the ECAP ISR</h3>
<p>In the last section, we enabled an interrupt on the ECAP in SysConfig. The corresponding interrupt service routine (ISR) is named <code>ecap1ISR</code> and is shown below. The global variable <code>eCapPwmPeriod</code> stores the difference between the ECAP timestamps from event 3 and 1, which allows us to calculate the period. Since the ECAP units operate on the system clock, the frequency of the PWM waveform can be calculated using:</p>
<p>fpwmâ‰ˆDEVICE_SYSCLK_FREQeCapPwmPeriod.</p>
<p>The global variable <code>eCapPwmDuty</code> will store the difference between the ECAP timestamps from event 2 and 1, which allows us to calculate the duty cycle. The duty cycle can be calculated via:</p>
<p>dutyâ‰ˆeCapPwmDutyeCapPwmPeriod100.</p>
<p>Copy the following code into your source .c file:</p>
<pre><code>__interrupt void ecap1ISR(void)
{
    Interrupt_clearACKGroup(INT_myECAP0_INTERRUPT_ACK_GROUP);
    ECAP_clearGlobalInterrupt(myECAP0_BASE);
    ECAP_clearInterrupt(myECAP0_BASE, ECAP_ISR_SOURCE_CAPTURE_EVENT_3);
    eCapPwmDuty = (int32_t)ECAP_getEventTimeStamp(myECAP0_BASE, ECAP_EVENT_2) -
                  (int32_t)ECAP_getEventTimeStamp(myECAP0_BASE, ECAP_EVENT_1);
    eCapPwmPeriod = (int32_t)ECAP_getEventTimeStamp(myECAP0_BASE, ECAP_EVENT_3) -
                    (int32_t)ECAP_getEventTimeStamp(myECAP0_BASE, ECAP_EVENT_1);
}
</code></pre>
<h2 id="program-setup">Program Setup</h2>
<h3 id="define-global-macros-and-variables">Define Global Macros and Variables</h3>
<p>At the top of your source .c file (after any included files), copy the following code to define necessary macros and global variables.</p>
<pre><code>uint32_t ePwm_TimeBase;
uint32_t ePwm_MinDuty;
uint32_t ePwm_MaxDuty;
uint32_t ePwm_curDuty;
uint16_t AdcBuf[50];            // Buffer to store ADC samples.
uint16_t *AdcBufPtr = AdcBuf;   // Pointer to ADC buffer samples.
uint16_t LedCtr = 0;            // Counter to slow down LED toggle in ADC ISR.
uint16_t DutyModOn = 0;         // Flag to turn on/off duty cycle modulation.
uint16_t DutyModDir = 0;        // Flag to control duty mod direction up/down.
uint16_t DutyModCtr = 0;        // Counter to slow down rate of modulation.
int32_t eCapPwmDuty;            // Percent = (eCapPwmDuty/eCapPwmPeriod)*100.
int32_t eCapPwmPeriod;          // Frequency = DEVICE_SYSCLK_FREQ/eCapPwmPeriod.
</code></pre>
<h3 id="define-main">Define main()</h3>
<p>Next, we will populate <code>main()</code> as shown below.</p>
<p>We will still need to know the system clock frequency in order to configure our PWM waveform frequency. The system clock frequency value is defined via the macro <code>DEVICE_SYSCLK_FREQ</code> in <code>[projectroot]/device/device.h</code>. Observe that the main function only handles initialization routines. Most of the activity in this lab lies in the peripherals themselves and their interrupt service routines.</p>
<p>Copy the following code into your source .c file:</p>
<pre><code>void main(void)
{
    Device_init();
    Interrupt_initModule();
    Interrupt_initVectorTable();
    Board_init();
    // Initialize variables for EPWM Duty Cycle
    ePwm_TimeBase = EPWM_getTimeBasePeriod(myEPWM0_BASE);
    ePwm_MinDuty = (uint32_t)(0.95f * (float)ePwm_TimeBase);
    ePwm_MaxDuty = (uint32_t)(0.05f * (float)ePwm_TimeBase);
    ePwm_curDuty = EPWM_getCounterCompareValue(myEPWM0_BASE, EPWM_COUNTER_COMPARE_A);
    EINT;
    ERTM;
    for (;;) {
        NOP;
    }
}
</code></pre>
<p>This concludes the coding portion of this lab.</p>
<h2 id="build-and-run-the-project">Build and Run the Project</h2>
<ol>
<li>Ensure that the USB cable from your LaunchPad or controlCARD is connected to your computer.</li>
<li>Under the <strong>Build</strong> button, activate the <strong>CPU1_RAM</strong> build configuration.</li>
<li>Make sure your projectâ€™s target configuration file (.ccxml) is active.</li>
<li>Connect the EPWM1A GPIO pin to the ADCINA0 GPIO pin using a jumper cable. If you have an oscilloscope, connect a probe to the EPWM1A GPIO pin on your board.</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Device</th>
<th style="text-align:left">ADCINA0 Pin</th>
<th style="text-align:left">EPWM1A Pin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">F28379D</td>
<td style="text-align:left">30</td>
<td style="text-align:left">40</td>
</tr>
<tr>
<td style="text-align:left">F2838x</td>
<td style="text-align:left">n/a</td>
<td style="text-align:left">n/a</td>
</tr>
<tr>
<td style="text-align:left">F28004x</td>
<td style="text-align:left">70</td>
<td style="text-align:left">80</td>
</tr>
<tr>
<td style="text-align:left">F28002x</td>
<td style="text-align:left">69</td>
<td style="text-align:left">40</td>
</tr>
<tr>
<td style="text-align:left">F28003x</td>
<td style="text-align:left">70</td>
<td style="text-align:left">40</td>
</tr>
<tr>
<td style="text-align:left">F280013x</td>
<td style="text-align:left">69</td>
<td style="text-align:left">40</td>
</tr>
<tr>
<td style="text-align:left">F280015x</td>
<td style="text-align:left">69</td>
<td style="text-align:left">36</td>
</tr>
<tr>
<td style="text-align:left">F28P65x</td>
<td style="text-align:left">30</td>
<td style="text-align:left">78</td>
</tr>
<tr>
<td style="text-align:left">F28P55x</td>
<td style="text-align:left">70</td>
<td style="text-align:left">40</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Device</th>
<th style="text-align:left">ADCINA0 Pin</th>
<th style="text-align:left">EPWM1A Pin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">F28379D</td>
<td style="text-align:left">9</td>
<td style="text-align:left">49</td>
</tr>
<tr>
<td style="text-align:left">F2838x</td>
<td style="text-align:left">9</td>
<td style="text-align:left">49</td>
</tr>
<tr>
<td style="text-align:left">F28004x</td>
<td style="text-align:left">9</td>
<td style="text-align:left">49</td>
</tr>
<tr>
<td style="text-align:left">F28002x</td>
<td style="text-align:left">9</td>
<td style="text-align:left">49</td>
</tr>
<tr>
<td style="text-align:left">F28003x</td>
<td style="text-align:left">9</td>
<td style="text-align:left">49</td>
</tr>
<tr>
<td style="text-align:left">F280013x</td>
<td style="text-align:left">9</td>
<td style="text-align:left">49</td>
</tr>
<tr>
<td style="text-align:left">F280015x</td>
<td style="text-align:left">9</td>
<td style="text-align:left">49</td>
</tr>
<tr>
<td style="text-align:left">F28P65x</td>
<td style="text-align:left">9</td>
<td style="text-align:left">49</td>
</tr>
<tr>
<td style="text-align:left">F28P55x</td>
<td style="text-align:left">9</td>
<td style="text-align:left">49</td>
</tr>
</tbody>
</table>
<ol>
<li>Now we will start the debug session. Under the debug button, start the debug session using the new configuration. You should now see the debugging session open up and the debugger should have reached <code>main()</code>.</li>
<li>Click the <strong>Resume</strong> button. You should see the LED on your board toggling at about 1Hz which indicates that the sampling rate is 50kHz as desired.</li>
<li>Find the <code>eCapPwmDuty</code> and <code>eCapPwmPeriod</code> global variables in the debug source code window, highlight their text, right click, and click <strong>Add Watch Expression</strong>. Activate the <strong>Continuous Refresh</strong> option. If all is well, the expressions pane should show values of <code>eCapPwmDuty</code> and <code>eCapPwmPeriod</code> such that eCapPwmDutyeCapPwmPeriod100â‰ˆ25 which indicates the correct duty cycle of 25%. Additionally, DEVICE_SYSCLK_FREQeCapPwmPeriodâ‰ˆ2000 which indicates the correct PWM frequency of 2kHz.</li>
</ol>
<figure data-type="image" tabindex="21"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/watch_expression.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/watch_expression.png" alt="../../../_images/watch_expression.png" loading="lazy"></a></figure>
<ol start="8">
<li>Now we will view our waveform from the samples in <code>AdcBuf</code>. Click on <strong>Tools â†’ Graph â†’ Single Time</strong>, and use the following settings:</li>
</ol>
<ul>
<li><em>Acquisition Buffer Size</em>: 50</li>
<li><em>Dsp Data Type</em>: 16 bit unsigned integer</li>
<li><em>Sampling Rate Hz</em>: 50000</li>
<li><em>Start Address</em>: AdcBuf</li>
<li><em>Time Display Unit</em>: us</li>
<li>Leave the other settings as their default value. Click <strong>OK</strong> and you should see the plot window open up.</li>
<li>Activate the <strong>Continuous Refresh</strong> option in the plot window. You should now see several periods of the PWM waveform in the plot updating in real-time. If desired, you can use the measurement tool to verify the duty cycle and period.</li>
</ul>
<figure data-type="image" tabindex="22"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/plot_setup1.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/plot_setup1.png" alt="../../../_images/plot_setup1.png" loading="lazy"></a></figure>
<p>\</p>
<p>Important</p>
<p>Note: If you do not see CCS menu <strong>Tools â†’ Graph</strong>, please refer to <a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/source/c2000_get_started/c2000_getstarted.html">Getting Started (Setting CCS for graph)</a> to see the instruction on how to enable CCS graphing tool in your perspective.</p>
<figure data-type="image" tabindex="23"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/plot_pwm1.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/plot_pwm1.png" alt="../../../_images/plot_pwm1.png" loading="lazy"></a></figure>
<p>\</p>
<ol>
<li>Next, add <code>ePwm_curDuty</code> to the watch expression list. Play with values of <code>ePwm_curDuty</code> from 1250 to 23750. You should see the duty cycle of the PWM waveform change in real-time in the plot window. The readings from the ECAP should also update in real-time.</li>
<li>Add <code>DutyModOn</code> to the watch expression list. Change the value to 1. You should now see the duty cycle modulate in real-time from 5% to 95% in the plot window.</li>
</ol>
<figure data-type="image" tabindex="24"><a href="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/plot_pwm_mod.png"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/plot_pwm_mod.png" alt="../../../_images/plot_pwm_mod.png" loading="lazy"></a></figure>
<p>\</p>
<ol>
<li>Terminate the debug session and close the project. This concludes the lab assignment.</li>
</ol>
<h2 id="full-solution">Full Solution</h2>
<p>The full solution to this lab exercise is included as part of the C2000Ware SDK. Import the project from <code>&lt;c2000ware_install_path&gt;/training/device/&lt;device_name&gt;/control_peripherals/lab_ePwm_eCap</code>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C2000æ§åˆ¶å™¨---ä¸­æ–­ç³»ç»Ÿ]]></title>
        <id>https://funmod.github.io/post/c2000-kong-zhi-qi-adc/</id>
        <link href="https://funmod.github.io/post/c2000-kong-zhi-qi-adc/">
        </link>
        <updated>2024-11-06T13:34:37.000Z</updated>
        <content type="html"><![CDATA[<p>ä¸­æ–­æ˜¯å¤„ç†å™¨å¯¹éœ€è¦æ³¨æ„çš„äº‹ä»¶çš„å“åº”ã€‚å¤„ç†å™¨ä¼šå°½å¿«æ‰§è¡Œä¸­æ–­æœåŠ¡ä¾‹ç¨‹ (ISR) ä¸­å®šä¹‰çš„æŒ‡ä»¤ï¼Œç„¶åè¿”å›æ­£å¸¸çš„æ“ä½œä»»åŠ¡ã€‚ä¸ä»£ç ç­‰å¾…äº‹ä»¶å‘ç”Ÿçš„ç©ºé—²å¾ªç¯ä¸åŒï¼Œä¸­æ–­æä¾›äº†æ ¹æ® CPU çš„å¯ç”¨æ€§å’Œä»»åŠ¡ä¼˜å…ˆçº§æ‰§è¡Œéç©ºé—²ä»£ç å¾ªç¯çš„æœºä¼šã€‚</p>
<h2 id="c2000è®¾å¤‡ä¸­çš„ä¸­æ–­æ¶æ„">C2000è®¾å¤‡ä¸­çš„ä¸­æ–­æ¶æ„</h2>
<p>è¯·å‚é˜…Device Interrupt Architectureâ€™ figure of the deviceâ€™s Technical Reference Manual (TRM)çš„â€œè®¾å¤‡ä¸­æ–­æ¶æ„â€å›¾ï¼Œä»¥ç›´è§‚åœ°äº†è§£ä¸‹è¿°ä¸­æ–­æ¶æ„ã€‚<br>
å†…éƒ¨ä¸­æ–­æºåŒ…æ‹¬é€šç”¨å®šæ—¶å™¨ 0ã€1 å’Œ 2ï¼Œä»¥åŠC2000ä¸Šçš„æ‰€æœ‰å¤–è®¾ã€‚<br>
å¤–éƒ¨ä¸­æ–­æºåŒ…æ‹¬äº”ä¸ªå¤–éƒ¨ä¸­æ–­çº¿ã€‚ä»è¾“å…¥ X-BAR ä¸­ï¼ŒINPUT4 æ˜ å°„åˆ° XINT1ï¼ŒINPUT5 æ˜ å°„åˆ° XINT2ï¼ŒINPUT6 æ˜ å°„åˆ° XINT3ï¼ŒINPUT13 æ˜ å°„åˆ° XINT4ï¼ŒINPUT14 æ˜ å°„åˆ° XINT5ã€‚<br>
å¤–è®¾ä¸­æ–­æ‰©å±•å—ï¼Œç§°ä¸ºPIEå—ï¼Œç”¨äºæ‰©å±•å†…æ ¸ä¸­æ–­èƒ½åŠ›ã€‚å®šæ—¶å™¨ 0 ç›´æ¥è¿æ¥åˆ° PIE æ¨¡å—ä»¥åŠæ¥è‡ªçœ‹é—¨ç‹—æ¨¡å—çš„ WAKEINT ä¿¡å·ã€‚å¯¹äºåŒæ ¸å™¨ä»¶ï¼Œæ¯ä¸ªå†…æ ¸éƒ½æœ‰è‡ªå·±çš„ PIE å—ï¼Œä¸¤ä¸ªå†…æ ¸ä¹‹é—´å…±äº« XINTx ä¿¡å·ä»¥åŠå¤–è®¾ä¸­æ–­å’Œå¤„ç†å™¨é—´ (IPC) ä¿¡å·ã€‚</p>
<p>è¯¥å†…æ ¸æœ‰ 14 æ¡ä¸­æ–­çº¿ï¼ˆå¯¹äºåŒæ ¸å™¨ä»¶ï¼Œæ¯ä¸ªå†…æ ¸éƒ½æœ‰è‡ªå·±çš„ä¸€ç»„ 14 æ¡ä¸­æ–­çº¿ï¼‰ã€‚ä¸­æ–­1-12 æ¥è‡ªPIE å—ï¼Œä¸­æ–­13 æ˜ å°„åˆ°å®šæ—¶å™¨1ï¼Œä¸­æ–­14 æ˜ å°„åˆ°å®šæ—¶å™¨2ã€‚NMI æ¨¡å—ç›´æ¥è¿æ¥åˆ°æ˜ å°„åˆ°å†…æ ¸çš„NMI ä¸­æ–­ã€‚</p>
<figure data-type="image" tabindex="1"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/PIE.png" alt="Peripheral Interrupt Expansion" loading="lazy"></figure>
<p>å¤–è®¾ä¸­æ–­æ‰©å±• (PIE) æ¨¡å—å°†å¤šè¾¾ 16 ä¸ªå¤–è®¾ä¸­æ–­å¤šè·¯å¤ç”¨åˆ° 12 ä¸ª CPU ä¸­æ–­çº¿ä¸­çš„æ¯ä¸€ä¸ªä¸­ï¼Œè¿›ä¸€æ­¥æ‰©å±•äº†å¯¹å¤šè¾¾ 192 ä¸ªå¤–è®¾ä¸­æ–­ä¿¡å·çš„æ”¯æŒã€‚</p>
<p>PIEæ¨¡å—è¿˜æ‰©å±•äº†ä¸­æ–­å‘é‡è¡¨ï¼Œå…è®¸æ¯ä¸ªç‹¬ç‰¹çš„ä¸­æ–­ä¿¡å·æ‹¥æœ‰è‡ªå·±çš„ä¸­æ–­æœåŠ¡ä¾‹ç¨‹ï¼ˆISRï¼‰ï¼Œä»è€Œå…è®¸CPUæ”¯æŒå¤§é‡å¤–è®¾ã€‚</p>
<p>PIE å—åŒ…å« 12 ä¸ªç»„ã€‚åœ¨æ¯ä¸ªç»„å†…ï¼Œæœ‰åå…­ä¸ªä¸­æ–­æºã€‚æ¯ä¸ªç»„å…·æœ‰ä¸€ä¸ª PIE ä¸­æ–­ä½¿èƒ½å¯„å­˜å™¨å’Œä¸€ä¸ª PIE ä¸­æ–­æ ‡å¿—å¯„å­˜å™¨ã€‚<br>
ä»»ä½•ä¸ç»è¿‡ PIE å—çš„ä¸­æ–­çº¿éƒ½ç›´æ¥è¿æ¥åˆ° CPUï¼Œä¾‹å¦‚è®¡æ—¶å™¨ 1/2 å’Œ NMIã€‚</p>
<p>æ³¨æ„ï¼š<br>
è¦æŸ¥çœ‹ PIE å—æ˜ å°„ï¼Œè¯·å‚é˜…è®¾å¤‡æŠ€æœ¯å‚è€ƒæ‰‹å†Œ (TRM) ä¸­çš„â€œPIE é€šé“æ˜ å°„â€è¡¨ã€‚</p>
<p>ä¸‹å›¾æ˜¾ç¤ºäº† F2838x å™¨ä»¶çš„ PIE é€šé“æ˜ å°„ç¤ºä¾‹ã€‚</p>
<figure data-type="image" tabindex="2"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/pie_channel_mapping.png" alt="PIE Channel Mapping Example" loading="lazy"></figure>
<p>PIE åˆ†é…è¡¨å°†æ¯ä¸ªå¤–è®¾ä¸­æ–­æ˜ å°„åˆ°è¯¥ä¸­æ–­æœåŠ¡ä¾‹ç¨‹çš„å”¯ä¸€å‘é‡ä½ç½®ã€‚å·¦ä¾§ï¼ˆè¡Œï¼‰çš„ä¸­æ–­å·ä»£è¡¨ 12 ä¸ªæ ¸å¿ƒç»„ä¸­æ–­çº¿ï¼Œé¡¶éƒ¨ï¼ˆåˆ—ï¼‰çš„ä¸­æ–­å·ä»£è¡¨æ ¸å¿ƒç»„ä¸­æ–­çº¿å†…çš„é€šé“å·ã€‚<br>
12 ä¸ª PIE ç»„ä¸­çš„æ¯ä¸€ä¸ªéƒ½æœ‰ä¸€ä¸ª 16 ä½æ ‡å¿—å¯„å­˜å™¨ (PIEIFRx)ã€ä¸€ä¸ª 16 ä½ä½¿èƒ½å¯„å­˜å™¨ (PIEIERx) å’Œ PIE åº”ç­”å¯„å­˜å™¨ (PIEACK) ä¸­çš„ä¸€ä¸ªä½å­—æ®µï¼Œè¯¥ä½å­—æ®µå……å½“æ•´ä¸ªç»„çš„å…¬å…±ä¸­æ–­å±è”½ã€‚<br>
ä¸ºäº†å°†å¤–è®¾ä¸­æ–­ä¼ æ’­åˆ° CPUï¼Œå¿…é¡»è®¾ç½®é€‚å½“çš„ PIEIFRã€ä½¿èƒ½ PIEIERã€è®¾ç½® CPU IFRã€ä½¿èƒ½ IER å’Œä½¿èƒ½ INTMã€‚è¯·æ³¨æ„ï¼ŒæŸäº›å¤–è®¾å¯èƒ½æœ‰å¤šä¸ªäº‹ä»¶è§¦å‘åŒä¸€ä¸ªä¸­æ–­ä¿¡å·ï¼Œå¯ä»¥é€šè¿‡è¯»å–å¤–è®¾çš„çŠ¶æ€å¯„å­˜å™¨æ¥ç¡®å®šä¸­æ–­åŸå› ã€‚<br>
PIECTRL å¯„å­˜å™¨ä¸­çš„ä½¿èƒ½ PIE ä½ç”¨äºæ¿€æ´» PIE æ¨¡å—ã€‚è¯·æ³¨æ„ï¼Œå½“ä½¿ç”¨Driverlibå‡½æ•°å¯ç”¨å’Œç¦ç”¨ä¸­æ–­æ—¶ï¼ŒPIEIERå’ŒCPUå†…æ ¸IERå¯„å­˜å™¨éƒ½ä¼šè¢«ä¿®æ”¹ã€‚<br>
Driverlib å‡½æ•°å¯ä¿®æ”¹ PIEIER å’Œæ ¸å¿ƒ IER å¯„å­˜å™¨ï¼š</p>
<pre><code class="language-c">Interrupt_enable(interruptNumber);
Interrupt_disable(interruptNumber);
</code></pre>
<h2 id="pie-å—åˆå§‹åŒ–">PIE å—åˆå§‹åŒ–</h2>
<p>è°ƒç”¨ä¸¤ä¸ªå•ç‹¬çš„å‡½æ•°æ¥åˆå§‹åŒ–ä¸­æ–­æ¨¡å—å’Œ PIE å—ã€‚</p>
<pre><code class="language-c">Interrupt_initModule();
Interrupt_initVectorTable();
</code></pre>
<p>åœ¨å¤„ç†å™¨åˆå§‹åŒ–æœŸé—´ï¼ŒPIE ä¸­æ–­æ˜ å°„è¡¨ä¸­æ˜ å°„çš„ä¸­æ–­å‘é‡è¢«å¤åˆ¶åˆ° PIE RAMï¼Œç„¶åé€šè¿‡å°† ENPIE è®¾ç½®ä¸ºâ€œ1â€æ¥å¯ç”¨ PIE æ¨¡å—ã€‚<br>
å½“CPUæ¥æ”¶åˆ°ä¸­æ–­æ—¶ï¼Œä»PIE RAMä¸­å–å‡ºISRçš„å‘é‡åœ°å€ï¼Œå¹¶æ‰§è¡Œè¢«æ ‡è®°å’Œä½¿èƒ½çš„å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§çš„ä¸­æ–­ã€‚<br>
ä¼˜å…ˆçº§ç”±ä¸­æ–­å‘é‡è¡¨ä¸­çš„ä½ç½®å†³å®šã€‚å½“æœ‰å¤šä¸ªä¸­æ–­å¾…å¤„ç†æ—¶ï¼Œç¼–å·æœ€ä½çš„ä¸­æ–­å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§ã€‚<br>
ç»¼ä¸Šæ‰€è¿°ï¼ŒPIEåˆå§‹åŒ–ä»£ç æµç¨‹å¦‚ä¸‹ï¼š</p>
<ul>
<li>è®¾å¤‡å¤ä½å¹¶å®Œæˆå¯åŠ¨ä»£ç æ‰§è¡Œåï¼Œæ‰€é€‰çš„å¯åŠ¨é€‰é¡¹å°†ç¡®å®šä»£ç å…¥å£ç‚¹ã€‚</li>
<li>CodeStartBranch.asm æ–‡ä»¶æœ‰ä¸€æ¡æŒ‡å‘è¿è¡Œæ—¶æ”¯æŒåº“å…¥å£ç‚¹çš„é•¿åˆ†æ”¯æŒ‡ä»¤ã€‚è¿è¡Œæ—¶æ”¯æŒåº“å®Œæˆæ‰§è¡Œåï¼Œè°ƒç”¨mainã€‚</li>
<li>main ä¸­è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ¥åˆå§‹åŒ–ä¸­æ–­è¿‡ç¨‹å¹¶å¯ç”¨ PIE æ¨¡å—ã€‚</li>
<li>å½“CPUæ¥æ”¶åˆ°ä¸­æ–­æ—¶ï¼Œä»PIE RAMä¸­å–å‡ºISRçš„å‘é‡åœ°å€ï¼Œå¹¶æ‰§è¡Œè¢«æ ‡è®°å’Œä½¿èƒ½çš„å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§çš„ä¸­æ–­ã€‚</li>
<li>ä¼˜å…ˆçº§ç”±ä¸­æ–­å‘é‡è¡¨ä¸­çš„ä½ç½®å†³å®šã€‚</li>
</ul>
<h2 id="ä¸­æ–­å¤„ç†">ä¸­æ–­å¤„ç†</h2>
<figure data-type="image" tabindex="3"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/maskable_interrupt_sources.png" alt="Maskable Interrupt Processing" loading="lazy"></figure>
<p>é€šè¿‡ä½¿ç”¨ä¸€ç³»åˆ—æ ‡å¿—å’Œä½¿èƒ½å¯„å­˜å™¨ï¼ŒCPU å¯ä»¥é…ç½®ä¸ºæœåŠ¡ä¸€ä¸ªä¸­æ–­ï¼Œè€Œå…¶ä»–ä¸­æ–­åˆ™ä¿æŒå¾…å¤„ç†çŠ¶æ€ï¼Œæˆ–è€…åœ¨æœåŠ¡æŸäº›å…³é”®ä»»åŠ¡æ—¶å¯èƒ½è¢«ç¦ç”¨ã€‚</p>
<ul>
<li>ä¸­æ–­æ ‡å¿—å¯„å­˜å™¨ï¼ˆIFRï¼‰ï¼šå½“æ ¸å¿ƒçº¿ä¸Šå‡ºç°ä¸­æ–­ä¿¡å·æ—¶ï¼Œè¯¥æ ¸å¿ƒçº¿çš„ IFR è¢«è®¾ç½®ã€‚</li>
<li>ä¸­æ–­å¯ç”¨å¯„å­˜å™¨ (IER)ï¼šå¦‚æœä¸ºæ‰€éœ€çš„å†…æ ¸çº¿å¯ç”¨äº†é€‚å½“çš„ IER å¹¶ä¸”å¯ç”¨äº† INTMï¼Œåˆ™ä¸­æ–­ä¿¡å·å°†ä¼ æ’­åˆ°å†…æ ¸ã€‚</li>
<li>ä¸­æ–­å…¨å±€å±è”½ (INTM)ï¼šæ­¤å¼€å…³æ˜¯å…è®¸ä¸­æ–­ä¼ æ’­åˆ°å†…æ ¸çš„å…¨å±€å¼€å…³ã€‚</li>
</ul>
<p>ä¸ºäº†å¯¹ä¸­æ–­ä»»åŠ¡è¿›è¡Œç¼–ç¨‹ï¼Œå¯ä»¥å°†ä¸­æ–­æœåŠ¡ä¾‹ç¨‹ (ISR) é“¾æ¥åˆ°ä¸­æ–­ã€‚</p>
<ul>
<li>ä¸€æ—¦ ISR å¼€å§‹å¤„ç†ä¸­æ–­ï¼ŒINTM ä½å°†è¢«ç¦ç”¨ä»¥é˜²æ­¢åµŒå¥—ä¸­æ–­ã€‚</li>
<li>IFR è¢«æ¸…é™¤å¹¶å‡†å¤‡å¥½æ¥æ”¶ä¸‹ä¸€ä¸ªä¸­æ–­ä¿¡å·ã€‚</li>
<li>å½“ä¸­æ–­æœåŠ¡å®Œæˆæ—¶ï¼ŒINTM ä½è‡ªåŠ¨ä½¿èƒ½ï¼Œå…è®¸å¤„ç†ä¸‹ä¸€ä¸ªä¸­æ–­ã€‚è¯·æ³¨æ„ï¼Œå½“ INTM ä½ä¸ºâ€œ0â€æ—¶ï¼Œâ€œå¼€å…³â€å…³é—­å¹¶å¯ç”¨ã€‚å½“è¯¥ä½ä¸ºâ€œ1â€æ—¶ï¼Œâ€œå¼€å…³â€æ‰“å¼€å¹¶ç¦ç”¨ã€‚çŠ¶æ€å¯„å­˜å™¨ä¸­çš„ INTM ä½é€šè¿‡ä½¿ç”¨ Driverlib å‡½æ•°æˆ–å†…è”æ±‡ç¼–æŒ‡ä»¤ï¼ˆå®ï¼‰è¿›è¡Œç®¡ç†ã€‚</li>
<li>IER é€šè¿‡å¯ç”¨å’Œç¦ç”¨ Driverlib å‚æ•°å€¼è¿›è¡Œç®¡ç†ã€‚</li>
</ul>
<h2 id="ä¸­æ–­æ ‡å¿—å¯„å­˜å™¨ifr">ä¸­æ–­æ ‡å¿—å¯„å­˜å™¨ï¼ˆIFRï¼‰</h2>
<ul>
<li>ç¼–è¯‘å™¨ç”ŸæˆåŸå­æŒ‡ä»¤ï¼ˆä¸å¯ä¸­æ–­ï¼‰ç”¨äºè®¾ç½®/æ¸…é™¤IFR</li>
<li>å¦‚æœå†™å…¥ IFR æ—¶å‘ç”Ÿå¦ä¸€ä¸ªä¸­æ–­ï¼Œåˆ™è¯¥ä¸­æ–­å…·æœ‰ä¼˜å…ˆæƒã€‚</li>
<li>å½“ CPU é€šè¿‡ PIEACK å¯„å­˜å™¨ç¡®è®¤ä¸­æ–­æ—¶ï¼ŒIFR å¯„å­˜å™¨çš„ä½è¢«æ¸…é™¤ï¼ˆè¿™é€šå¸¸åœ¨ä¸­æ–­æœåŠ¡ä¾‹ç¨‹ (ISR) ç»“æŸæ—¶å®Œæˆï¼‰ã€‚</li>
</ul>
<p>ç”¨äºç¡®è®¤ PIE ç»„çš„ Driverlib å‡½æ•°ï¼š</p>
<pre><code class="language-C">// group parameter is a logical OR of the values: INTERRUPT_ACK_GROUPx, 
// where x is the interrupt number between 1 and 12

// Acknowledges group and clears any interrupt flag within group
// Required to receive further interrupts in PIE group (done in ISR)
  Interrupt_clearACKGroup(group);
</code></pre>
<ul>
<li>IFR å¯„å­˜å™¨åœ¨å¤ä½æ—¶è¢«æ¸…é™¤</li>
</ul>
<h2 id="ä¸­æ–­ä½¿èƒ½å¯„å­˜å™¨-ier">ä¸­æ–­ä½¿èƒ½å¯„å­˜å™¨ (IER)</h2>
<h2 id="ç¼–è¯‘å™¨ç”ŸæˆåŸå­æŒ‡ä»¤ä¸å¯ä¸­æ–­ç”¨äºè®¾ç½®æ¸…é™¤-ier">ç¼–è¯‘å™¨ç”ŸæˆåŸå­æŒ‡ä»¤ï¼ˆä¸å¯ä¸­æ–­ï¼‰ç”¨äºè®¾ç½®/æ¸…é™¤ IER</h2>
<p>IER åœ¨å¤ä½æ—¶è¢«æ¸…é™¤<br>
ç”¨äºä¿®æ”¹IERçš„Driverlibå‡½æ•°ï¼š</p>
<pre><code class="language-C">// cpuInterrupt parameter is a logical OR of the values:
// INTERRUPT_CPU_INTx, where x is the interrupt number between 1 and 14
// INTERRUPT_CPU_DLOGINT (CPU Data Log Interrupt)
// INTERRUPT_CPU_RTOSINT (CPU RTOS Interrupt)
Interrupt_enableInCPU(cpuInterrupt);
Interrupt_disableInCPU(cpuInterrupt);
</code></pre>
<h2 id="ä¸­æ–­å…¨å±€å±è”½ä½-intm">ä¸­æ–­å…¨å±€å±è”½ä½ (INTM)</h2>
<p>INTM ç”¨äºå…¨å±€å¯ç”¨/ç¦ç”¨ä¸­æ–­ï¼š<br>
â€¢ å¯ç”¨ï¼šINTM = 0<br>
â€¢ ç¦ç”¨ï¼šINTM = 1ï¼ˆå¤ä½å€¼ï¼‰<br>
ç”¨äºä¿®æ”¹INTMçš„Driverlibå‡½æ•°ï¼š</p>
<pre><code class="language-C">Interrupt_enableGlobal();
Interrupt_disableGlobal();
</code></pre>
<p>æˆ–è€…å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å®ï¼š</p>
<pre><code class="language-c">EINT; //defined as - asm(&quot; clrc INTM&quot;);
DINT; //defined as - asm(&quot; setc INTM&quot;);
</code></pre>
<h2 id="ä¸­æ–­ä¿¡å·æµ-æ€»ç»“">ä¸­æ–­ä¿¡å·æµ-æ€»ç»“</h2>
<p>æ¦‚æ‹¬æ¥è¯´ï¼Œä¸­æ–­è¿‡ç¨‹ä¸­ä¼šå‘ç”Ÿä»¥ä¸‹æ­¥éª¤ï¼š</p>
<ol>
<li>
<p>äº§ç”Ÿå¤–è®¾ä¸­æ–­å¹¶è®¾ç½® PIE ä¸­æ–­æ ‡å¿—å¯„å­˜å™¨ã€‚å¦‚æœPIEä¸­æ–­ä½¿èƒ½å¯„å­˜å™¨è¢«ä½¿èƒ½ï¼Œé‚£ä¹ˆå†…æ ¸ä¸­æ–­æ ‡å¿—å¯„å­˜å™¨å°†è¢«ç½®ä½ã€‚</p>
</li>
<li>
<p>å¦‚æœå†…æ ¸ä¸­æ–­ä½¿èƒ½å¯„å­˜å™¨å’Œå…¨å±€ä¸­æ–­å±è”½è¢«ä½¿èƒ½ï¼ŒPIEå‘é‡è¡¨å°†æŠŠä»£ç é‡å®šå‘åˆ°ä¸­æ–­æœåŠ¡ç¨‹åºã€‚</p>
</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/interrupt_signal_flow.png" alt="Interrupt Signal Flow" loading="lazy"></figure>
<h2 id="ä¸­æ–­å“åº”å’Œå»¶è¿Ÿ">ä¸­æ–­å“åº”å’Œå»¶è¿Ÿ</h2>
<h3 id="ä¸­æ–­å“åº”-ç¡¬ä»¶åºåˆ—">ä¸­æ–­å“åº” - ç¡¬ä»¶åºåˆ—</h3>
<figure data-type="image" tabindex="5"><img src="https://funmod.github.io/post-images/1731047984493.png" alt="" loading="lazy"></figure>
<h3 id="ä¸­æ–­å»¶è¿Ÿ">ä¸­æ–­å»¶è¿Ÿ</h3>
<p>ä¸­æ–­å»¶è¿Ÿæ˜¯ç†è§£å®æ—¶ç³»ç»Ÿå“åº”æ—¶é—´çš„ä¸€ä¸ªé‡è¦å› ç´ ã€‚è¯„ä¼°ç³»ç»Ÿä¸­æ–­å»¶è¿Ÿçš„å…¸å‹æ–¹æ³•æ˜¯ç¡¬ä»¶å“åº”ä¸­æ–­å¹¶åˆ†æ”¯åˆ°ä¸­æ–­å‘é‡ï¼ˆç¡¬ä»¶é”å­˜å’Œå“åº”ï¼‰æ‰€éœ€çš„å‘¨æœŸæ•°ã€‚</p>
<figure data-type="image" tabindex="6"><img src="https://dev.ti.com/tirex/explore/content/c28x_academy_1_00_00_00/_build_c28x_academy_1_00_00_00/_images/interrupt_latency.png" alt="Interrupt Latency" loading="lazy"></figure>
<p>æœ€å°å»¶è¿Ÿï¼ˆåˆ° ISR ä¸­å®é™…å·¥ä½œå‘ç”Ÿæ—¶ï¼‰ï¼š</p>
<ul>
<li>å†…éƒ¨ä¸­æ–­ï¼š14ä¸ªå‘¨æœŸ</li>
<li>å¤–éƒ¨ä¸­æ–­ï¼š16ä¸ªå‘¨æœŸ</li>
</ul>
<p>æœ€å¤§å»¶è¿Ÿï¼šå–å†³äºç­‰å¾…çŠ¶æ€ã€INTM ç­‰ã€‚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://funmod.github.io/post/hello-gridea/</id>
        <link href="https://funmod.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea ä¸»é¡µ</a><br>
<a href="https://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>Windows</strong>ï¼Œ<strong>MacOS</strong> æˆ– <strong>Linux</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>